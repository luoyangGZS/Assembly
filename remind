原文链接：https://blog.csdn.net/ming_147/article/details/126827407

一、组件化优点

1、提高编译运行速度
当我们的项目随着版本的不断迭代，随之增加的功能会越来越多，业务也会变得越来越复杂，最终会导致代码量急剧上升，相关的三方sdk也会不断的涌入，以至于，更改一处，就要全量编译运行，有时候甚至会出现，改一行而等10分钟的情况，非常的耗时，大大降低了开发效率。

而采取了组件化的方式后，相关业务模块，进行单独抽取，使得每个业务模块可以独立当做App存在，和其他模块，互不关联影响，在编译运行时期，只考虑本模块即可，从而减少了代码的编译量，提高了编译运行速度，节约了开发时间。

2、业务拆解，完全解耦
单独的业务模块进行抽取成一个独立的组件，也就是相互不关联的Module，在各自的模块中书写相关的代码，做到，业务拆解，人员拆解，实现真正的解耦。

3、功能复用，节约开发时间
所谓的功能复用，不仅仅是同项目之间的复用，更是以后同样功能模块的复用，比如A项目中有一个直播模块，后面开发的B项目也有，完全可以移植过来复用，无非就是UI等简单逻辑的修改。

4、责任明确，分工明确
组件化的项目，各个业务单独成Module，在独自的Module中开发相关的业务需求，相对于糅合到一个模块中的项目来说，业务之间拆分更加明确，更加清晰，我负责哪个业务，就去哪个组件下去写，使得所负责的任务清晰明确，后续定位问题，也能够第一时间发现并修改。



二、组件化步骤

1、代码架构拆分，合理规划
  一个项目从0到1的实施，少不了很多基础的依赖，比如网络，比如图片加载，比如一些第三方sdk等等，无论你的项目是否是组件化，这些潜在的前提，是必不可少的，可能不是组件化的项目，这些底层的使用会和业务相关的代码放到一起，但在组件化的项目，基础库和业务层还是要进行剥离的。

2、业务单独拆分为Module，可单独编译运行
上边已经阐述，组件化的最直接表现就是在业务模块，也就是根据项目的实际功能，拆分出符合的业务模块，比如社区，比如用户信息，比如商城等等，拆分之后，一定要能保持单独运行，本着合则依赖，拆则运行的态度，那么我们需要解决两个问题，一个是application和library之间的动态切换，另一个就是需要动态改变清单文件资源指向，毕竟单独运行的Module，必须有一个主入口的存在。


3、各模块统一依赖，统一版本号
随着业务功能的不断增加，相关的组件也会随着增加，如果各个组件，都进行单独依赖，一旦依赖多了之后，就会出现重复依赖，版本号不一致的情况，针对这种问题，最直接的处理方式是，统一gradle文件，也就是所有的组件统一使用一个，除了一些特殊的依赖之外，其他的都放在统一的文件之中。

gradle文件抽取封装之后，便于所有的依赖管理，也便于统一版本号依赖。如下所示，抽取之后，每个组件下的build.gradle文件里，直接使用统一的文件即可，在代码上也是非常的清晰简单。

4、考虑问题一，组件之间页面跳转
由于组件之间互不依赖，一个突出的问题就是，页面之间如何跳转，比如我A模块要跳转到B模块中的一个页面，我该如何跳转呢？

关于组件间跳转，这个市场上已经有很多成熟的三方了，比如ARouter ，ActivityRouter，DeepLinkDispatch等等，当然用的比较多的就是ARouter了，已经有了成熟的，我们直接使用即可，没有必要再重复的造轮子。

通过ARouter 可以很方便的实现组件之间的通信，更重要的是方便了H5和原生交互之间的跳转。

”一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦“，这是github 上 ARouter 的相关介绍，可以知道，它可以实现组件间的路由功能，路由是指从一个接口上收到数据包，根据数据路由包的目的地址进行定向并转发到另一个接口的过程，这里可以体现出路由跳转的特点，非常适合组件化解耦。

使用起来也是非常的简单

 ARouter.getInstance().build("/test/test").navigation()

5、考虑问题二，组件之间数据传递
数据之间的传递，如果是页面单纯的传递数据，直接可以使用ARouter提供的传递方式，比如：

ARouter.getInstance().build("/test/test")
            .withLong("key1", 666L)
            .withString("key3", "888")
            .withObject("key4", new Test("Jack", "Rose"))
            .navigation();
如果不是页面之间的传递，那么就需要我们自己定义接口或者通过中间层common来实现了，当然了需要进行逻辑处理

6、考虑问题三，组件之间Fragment使用
A组件要想使用B组件里的Fragment，我们可以通过反射的方式进行获取，既然有了ARouter，我们直接可以使用ARouter提供的方式，非常的简单。

fragment = (Fragment) ARouter.getInstance().build("/test/fragment").navigation()

7、考虑问题四，组件之间功能互相调用
A组件想要触发B组件里一个功能，一个事件，那么如何处理呢？这个可以利用ARouter的IProvider，具体可以看下面的实战中代码。

8、考虑问题五，组件之间资源命名
组件多了，资源命名难免会出现重复，比如类名，比如layout名字，比如string名字，再比如其他的资源名等等，在实际的开发中，一旦名字重复，有可能造成资源冲突等问题，为了避免这样的问题出现，一般我们在组件化开发的时候，以组件的名字做为前缀，可以进行避免。
